import random
import time
import ratings

RANDOM_PERMS_ANTI_CONVERGENCE=87
POPULATION_SIZE=200
MAX_GENERATION_NUM =2000
ELITE_GROUP_SIZE=10
ACCEPTABLE_GRADE=10
MUTATION_RATE = 0.1
CONVERGENCE = 40
alphabet = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
rating_dictionary = ratings.trigrams
function_count=0

def generate_random_permutation():
    perm = list(alphabet)
    random.shuffle(perm)
    return perm

# turn text into long string of uppercase letters
def extract_letters(text):
    letters = ''.join(c for c in text if c.isalpha())
    return letters.upper()

def translate(perm, enc_text):
    decoded_text = enc_text.translate(str.maketrans(''.join(perm), 'abcdefghijklmnopqrstuvwxyz'))
    return decoded_text

def init(enc_text):
    #create a random perm of alphabet
    population = {}
    while len(population) < POPULATION_SIZE:
        #create random perm
        perm = generate_random_permutation()
        decoded_text = translate(perm, enc_text)
        score = fitness(decoded_text)
        population[''.join(perm)] = score
        #print(population, len(population))
    return population

def fitness(raw_text):
    text = extract_letters(raw_text)
    rating = 0
    global function_count
    function_count += 1
    #print(function_count, generation, individual_num)
    for window_right_index in range(3, len(text)):
        trigramStr = text[window_right_index - 3:window_right_index]
        if trigramStr in rating_dictionary:
            rating += rating_dictionary[trigramStr]
    return rating


def crossover(parent1, parent2):
    child = list(parent1)
    indices = sorted(random.sample(range(len(alphabet)), 2))
    for i in range(indices[0], indices[1]):
        child[i] = parent2[i]
    repaired_child = repair_key(child)
    mutated_child = mutate(repaired_child)
    return mutated_child


# Remove duplicate letters from a key and fill the missing letters
def repair_key(key):
    unique_letters = list(set(key))
    missing_letters = [c for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' if c not in unique_letters]
    replaced_key = ''
    letter_count = {}
    for letter in key:
        if letter in letter_count:
            if letter_count[letter] == 1:
                replaced_key += missing_letters.pop(0)
            else:
                replaced_key += letter
            letter_count[letter] += 1
        else:
            replaced_key += letter
            letter_count[letter] = 1

    return list(replaced_key)


def mutate(perm):
    for i in range(len(alphabet)):
        if random.random() < MUTATION_RATE:
            j = random.randint(0, len(alphabet) - 1)
            perm[i], perm[j] = perm[j], perm[i]
    return perm

def main(enc_file):
    best_results_random=[]
    for it in range(1):
        # Read the encoded file
        with open(enc_file, 'r') as f:
            encoded_text = f.read().upper()
        generation = 0
        population_dict = init(encoded_text)
        population_dict = dict(sorted(population_dict.items(), key=lambda x: x[1], reverse=True))

        # Create elite_population with the top 10 entries
        elite_population_dict = dict(list(population_dict.items())[:10])
        top_value = list(elite_population_dict.values())[0]
        print(generation,top_value, elite_population_dict)
        best_results_random.append(top_value)


        #while generation<MAX_GENERATION_NUM && top_value<ACCEPTABLE_GRADE,create new pop.
        j = 0
        while generation < MAX_GENERATION_NUM and top_value < ACCEPTABLE_GRADE:

            # create new population starting with the elite of previous gen
            new_population_dict =elite_population_dict
            if j >= CONVERGENCE:
                j=0
                for i in range(RANDOM_PERMS_ANTI_CONVERGENCE):
                    rands = generate_random_permutation()
                    dec = translate(rands, encoded_text)
                    rate = fitness(dec)
                    new_population_dict[''.join(rands)] = rate


            while len(new_population_dict) < POPULATION_SIZE:
                #add people to the population
                #call crossover and mutation functions: to return new perm
                # pick 2 parents randomly from elite_pop

                while True:
                    random_number1 = random.randint(0, 9)
                    random_number2 = random.randint(0, 9)
                    if(random_number1!=random_number2):
                        break

                elite_population_list=list(elite_population_dict.keys())
                parent1 = elite_population_list[random_number1]
                parent2 = elite_population_list[random_number2]
                perm = crossover(parent1, parent2)

                #rate each perm
                decoded_text = translate(perm, encoded_text)
                score = fitness(decoded_text)
                new_population_dict[''.join(perm)] = score

            #once population size is big enough:
            new_population_dict[''.join(perm)] = score
            new_population_dict=dict(sorted(new_population_dict.items(), key=lambda x: x[1], reverse=True))

            if(top_value<list(new_population_dict.values())[0]):
                j=0
            j+=1

            # Create elite_population with the top 10 entries
            elite_population_dict = dict(list(new_population_dict.items())[:10])
            top_value = list(elite_population_dict.values())[0]
            generation += 1
            print(generation,top_value, elite_population_dict)



        #outside the while - means I got here if I exceeded the max_generation_number, or if my top value is greater than acc_grade
        #here create the files needed.

    #end of for loop of num_of_iterations

    elite_population_list = list(elite_population_dict.keys())
    bestperm = elite_population_list[1]

    # Save the decoded text to plain.txt
    t = translate(bestperm, encoded_text)
    with open('plain.txt', 'w') as f:
        f.write(t)

    # Save the permutation to perm.txt

    with open('perm.txt', 'w') as f:
        f.write(bestperm)

if __name__ == '__main__':
    '''''
    with open('enc.txt', 'r') as f:
        encoded_text = f.read().upper()
    t= translate('YNIMJZGVCPBLHDFSXUQEWRAKTO',encoded_text)
    # Save the decoded text to plain.txt
    with open('plain.txt', 'w') as f:
        f.write(t)
        '''
    main('test1enc.txt')
    print("num of calls to fitness func:")
    print(function_count)
